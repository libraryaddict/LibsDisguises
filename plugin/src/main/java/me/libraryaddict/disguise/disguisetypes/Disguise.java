package me.libraryaddict.disguise.disguisetypes;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.wrapper.PacketWrapper;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerEntityAnimation;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerEntityStatus;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerHurtAnimation;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerPlayerInfo;
import lombok.Getter;
import lombok.Setter;
import me.clip.placeholderapi.PlaceholderAPI;
import me.libraryaddict.disguise.DisguiseAPI;
import me.libraryaddict.disguise.DisguiseConfig;
import me.libraryaddict.disguise.LibsDisguises;
import me.libraryaddict.disguise.disguisetypes.TargetedDisguise.TargetType;
import me.libraryaddict.disguise.disguisetypes.watchers.AbstractHorseWatcher;
import me.libraryaddict.disguise.disguisetypes.watchers.AgeableWatcher;
import me.libraryaddict.disguise.disguisetypes.watchers.BoatWatcher;
import me.libraryaddict.disguise.disguisetypes.watchers.LivingWatcher;
import me.libraryaddict.disguise.disguisetypes.watchers.SheepWatcher;
import me.libraryaddict.disguise.disguisetypes.watchers.ZombieWatcher;
import me.libraryaddict.disguise.events.DisguiseEvent;
import me.libraryaddict.disguise.events.UndisguiseEvent;
import me.libraryaddict.disguise.utilities.DisguiseUtilities;
import me.libraryaddict.disguise.utilities.LibsPremium;
import me.libraryaddict.disguise.utilities.animations.DisguiseAnimation;
import me.libraryaddict.disguise.utilities.movements.DisguisedVoiceChat;
import me.libraryaddict.disguise.utilities.movements.InteractiveBoundingBox;
import me.libraryaddict.disguise.utilities.parser.AutoGeneratedValue;
import me.libraryaddict.disguise.utilities.reflection.NmsVersion;
import me.libraryaddict.disguise.utilities.reflection.ReflectionManager;
import me.libraryaddict.disguise.utilities.sounds.DisguiseSoundCategory;
import me.libraryaddict.disguise.utilities.sounds.SoundGroup;
import me.libraryaddict.disguise.utilities.translations.LibsMsg;
import net.md_5.bungee.api.ChatMessageType;
import net.md_5.bungee.api.chat.BaseComponent;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.boss.BarColor;
import org.bukkit.boss.BarStyle;
import org.bukkit.boss.BossBar;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.AbstractHorse;
import org.bukkit.entity.Boat;
import org.bukkit.entity.Entity;
import org.bukkit.entity.FallingBlock;
import org.bukkit.entity.Item;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.metadata.FixedMetadataValue;
import org.bukkit.scheduler.BukkitRunnable;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

public abstract class Disguise {
    /**
     * In use doesn't mean that this disguise is active. It means that Lib's Disguises still stores a reference to
     * the disguise. Though it also means the disguise is active.
     * getEntity() can still return null if this disguise is active after despawn, logout, etc.
     *
     * @return isDisguiseInUse
     */
    @Getter
    private transient boolean disguiseInUse;
    private final DisguiseType disguiseType;
    /**
     * The entity that is disguised
     */
    @Getter
    private transient Entity entity;
    @Getter
    private String disguiseName;
    /**
     * Is the name specifically set to something by a third party?
     */
    @Getter
    @Setter
    private boolean customDisguiseName = false;
    @Getter
    private DisguiseConfig.TallSelfDisguise tallSelfDisguise = DisguiseConfig.getTallSelfDisguisesVisibility();
    @Getter
    private boolean replaceSounds = DisguiseConfig.isSoundEnabled();
    @Getter
    private boolean hearSelfDisguise = DisguiseConfig.isSelfDisguisesSoundsReplaced();
    private boolean viewSelfDisguise = DisguiseConfig.isViewDisguises() && DisguiseConfig.isViewSelfDisguisesDefault();
    @Getter
    @Setter
    private boolean playIdleSounds = DisguiseConfig.isPlayIdleSounds();
    @Getter
    private boolean hideArmorFromSelf = DisguiseConfig.isHidingArmorFromSelf();
    @Getter
    private boolean hideHeldItemFromSelf = DisguiseConfig.isHidingHeldItemFromSelf();
    @Getter
    private boolean velocitySent = DisguiseConfig.isVelocitySent();
    @Getter
    private boolean modifyBoundingBox = DisguiseConfig.isModifyBoundingBox();
    private String[] multiName = new String[0];
    private transient int[] armorstandIds = new int[0];
    @Getter
    @Setter
    private boolean dynamicName;
    @Getter
    @Setter
    private String soundGroup;
    @Getter
    @Setter
    @Nullable
    private DisguiseSoundCategory soundCategory;
    @Getter
    private DisguiseConfig.NotifyBar notifyBar = DisguiseConfig.getNotifyBar();
    @Getter
    private BarColor bossBarColor = DisguiseConfig.getBossBarColor();
    @Getter
    private BarStyle bossBarStyle = DisguiseConfig.getBossBarStyle();
    @Getter
    private boolean keepDisguiseOnPlayerDeath = DisguiseConfig.isKeepDisguiseOnPlayerDeath();
    private boolean playerHiddenFromTab = DisguiseConfig.isHideDisguisedPlayers();
    @Setter
    @Getter
    private boolean mobsIgnoreDisguise;
    /**
     * The unique FlagWatcher of this disguise
     */
    @Getter
    private FlagWatcher watcher;
    /**
     * If set, how long before disguise expires
     */
    protected long disguiseExpires;
    /**
     * For when plugins may want to assign custom data to a disguise, such as who owns it
     */
    private final LinkedHashMap<String, Object> customData = new LinkedHashMap<>();
    @Getter
    private final UUID disguiseUUID = ReflectionManager.getRandomUUID();
    /*
      If the player should see their own height grow/shrink to match the disguise
     */
    @Getter
    private boolean scalePlayerToDisguise = DisguiseConfig.isScaleSelfDisguises();
    @Getter
    @ApiStatus.Internal
    private final DisguiseInternals internals;

    public Disguise(DisguiseType disguiseType) {
        this.disguiseType = disguiseType;
        this.disguiseName = disguiseType.toReadable();
        this.internals = new DisguiseInternals(this);
    }

    protected void clone(Disguise disguise) {
        disguise.setDisguiseName(getDisguiseName());
        disguise.setCustomDisguiseName(isCustomDisguiseName());
        disguise.setTallSelfDisguise(getTallSelfDisguise());

        disguise.setReplaceSounds(isSoundsReplaced());
        disguise.setViewSelfDisguise(isSelfDisguiseVisible());
        disguise.setHearSelfDisguise(isSelfDisguiseSoundsReplaced());
        disguise.setPlayIdleSounds(isPlayIdleSounds());
        disguise.setHideArmorFromSelf(isHidingArmorFromSelf());
        disguise.setHideHeldItemFromSelf(isHidingHeldItemFromSelf());
        disguise.setVelocitySent(isVelocitySent());
        disguise.setModifyBoundingBox(isModifyBoundingBox());
        disguise.multiName = Arrays.copyOf(multiName, multiName.length);
        disguise.setDynamicName(isDynamicName());
        disguise.setSoundGroup(getSoundGroup());
        disguise.notifyBar = getNotifyBar();
        disguise.bossBarColor = getBossBarColor();
        disguise.bossBarStyle = getBossBarStyle();
        disguise.setExpires(getExpires());
        disguise.setScalePlayerToDisguise(isScalePlayerToDisguise());
        disguise.setHidePlayer(isHidePlayer());
        disguise.setKeepDisguiseOnPlayerDeath(isKeepDisguiseOnPlayerDeath());
        disguise.setMobsIgnoreDisguise(isMobsIgnoreDisguise());

        if (getWatcher() != null) {
            disguise.setWatcher(getWatcher().clone(disguise));
        }

        disguise.createDisguise();
    }

    public HashMap<String, Object> getCustomData() {
        return customData;
    }

    public UUID getUUID() {
        // If this is not a player disguise, or it is but we're not trying to make sure its unique
        if (!isPlayerDisguise() || !DisguiseConfig.isUniquePlayerDisguiseUUIDs()) {
            if (!DisguiseConfig.isRandomUUIDS() && getEntity() != null) {
                return getEntity().getUniqueId();
            }
        }

        return getDisguiseUUID();
    }

    public int getMultiNameLength() {
        return multiName.length;
    }

    @AutoGeneratedValue
    public void setDisguiseName(String name) {
        this.disguiseName = name;
    }

    public @NotNull DisguiseSoundCategory getEffectiveSoundCategory() {
        if (getSoundCategory() != null) {
            return getSoundCategory();
        }

        return SoundGroup.getGroup(this).getCategory();
    }

    /**
     * Gson will set the field to null which is undesired
     */
    private int[] getInternalArmorstandIds() {
        if (armorstandIds == null) {
            armorstandIds = new int[0];
        }

        return armorstandIds;
    }

    public String[] getMultiName() {
        if (multiName == null) {
            multiName = new String[0];
        }

        return multiName;
    }

    public void setMultiName(String... name) {
        if (name.length == 1 && name[0].isEmpty()) {
            name = new String[0];
        }

        Player player = getEntity() instanceof Player ? (Player) getEntity() : null;

        for (int i = 0; i < name.length; i++) {
            if (DisguiseUtilities.isPlaceholderApi() && name[i] != null && name[i].contains("%")) {
                name[i] = PlaceholderAPI.setPlaceholders(player, name[i]);
            }

            name[i] = DisguiseUtilities.getHexedColors(name[i]);
        }

        String[] oldName = multiName;
        multiName = name;

        if (Arrays.equals(oldName, name)) {
            return;
        }

        if (!isDisguiseInUse()) {
            return;
        }

        sendArmorStands(oldName);
    }

    public abstract double getHeight();

    public double getDisguiseScale() {
        if (!NmsVersion.v1_20_R4.isSupported()) {
            return 1;
        }

        if (!(getWatcher() instanceof LivingWatcher)) {
            return getInternals().getPlayerScaleWithoutLibsDisguises();
        }

        Double watcherScale = ((LivingWatcher) getWatcher()).getScale();

        if (watcherScale == null) {
            return getInternals().getPlayerScaleWithoutLibsDisguises();
        }

        return DisguiseUtilities.getClampedScale(watcherScale);
    }

    protected void sendArmorStands(String[] oldName) {
        if (!isDisguiseInUse()) {
            return;
        }

        adjustTallSelfDisguiseScale();

        for (Player player : DisguiseUtilities.getTrackingPlayers(this)) {
            if (!DisguiseUtilities.isFancyHiddenTabs() && isPlayerDisguise() &&
                LibsDisguises.getInstance().getSkinHandler().isSleeping(player, (PlayerDisguise) this)) {
                continue;
            }

            List<PacketWrapper<?>> packets = DisguiseUtilities.getNamePackets(this, player, oldName);

            for (PacketWrapper<?> packet : packets) {
                PacketEvents.getAPI().getPlayerManager().sendPacket(player, packet);
            }
        }
    }

    public int[] getArmorstandIds() {
        int desiredlength = getMultiNameLength();

        // If text display and there is a display
        if (getInternals().getNameDisplayType().isTextDisplayType() && desiredlength > 0) {
            // We only have the text display IDs
            desiredlength = 1;
        }

        if (desiredlength > getInternalArmorstandIds().length) {
            int oldLen = armorstandIds.length;

            armorstandIds = Arrays.copyOf(armorstandIds, desiredlength);

            for (int i = oldLen; i < armorstandIds.length; i++) {
                armorstandIds[i] = ReflectionManager.getNewEntityId();
            }
        }

        return armorstandIds;
    }

    public void addCustomData(String key, Object data) {
        customData.put(key, data);
    }

    public boolean hasCustomData(String key) {
        return customData.containsKey(key);
    }

    public Object getCustomData(String key) {
        return customData.get(key);
    }

    @Override
    public abstract Disguise clone();

    /**
     * Seems I do this method so I can make cleaner constructors on disguises..
     */
    protected void createDisguise() {
        if (getType().getEntityType() == null) {
            throw new RuntimeException("DisguiseType " + getType() +
                " was used in a futile attempt to construct a disguise, but this Minecraft version does not have " + "that entity");
        }

        // Get if they are a adult now..

        boolean isAdult = true;

        if (this instanceof MobDisguise) {
            isAdult = ((MobDisguise) this).isAdult();
        }

        if (getWatcher() == null) {
            try {
                // Construct the FlagWatcher from the stored class
                setWatcher(getType().getWatcherClass().getConstructor(Disguise.class).newInstance(this));
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else if (getWatcher().getDisguise() != this) {
            getWatcher().setDisguise((TargetedDisguise) this);
        }

        // Set the disguise if its a baby or not
        if (!isAdult) {
            if (getWatcher() instanceof AgeableWatcher) {
                ((AgeableWatcher) getWatcher()).setBaby(true);
            } else if (getWatcher() instanceof ZombieWatcher) {
                ((ZombieWatcher) getWatcher()).setBaby(true);
            }
        }
    }

    public boolean isDisguiseExpired() {
        return DisguiseConfig.isDynamicExpiry() ? disguiseExpires == 1 :
            disguiseExpires > 0 && disguiseExpires < System.currentTimeMillis();
    }

    public long getExpires() {
        return disguiseExpires;
    }

    public void setExpires(long timeToExpire) {
        disguiseExpires = timeToExpire;

        if (isDisguiseExpired()) {
            removeDisguise();
        }
    }

    private void removeBossBar() {
        BossBar bossBar = Bukkit.getBossBar(getInternals().getBossBar());

        if (bossBar == null) {
            return;
        }

        bossBar.removeAll();
        Bukkit.removeBossBar(getInternals().getBossBar());
    }

    public void setNotifyBar(DisguiseConfig.NotifyBar bar) {
        if (bar == null) {
            bar = DisguiseConfig.getNotifyBar();
        }

        if (getNotifyBar() == bar) {
            return;
        }

        if (getNotifyBar() == DisguiseConfig.NotifyBar.BOSS_BAR) {
            removeBossBar();
        }

        this.notifyBar = bar;

        makeBossBar();
    }

    public void setBossBarColor(BarColor color) {
        if (color == null) {
            color = DisguiseConfig.getBossBarColor();
        }

        if (getBossBarColor() == color) {
            return;
        }

        this.bossBarColor = color;

        makeBossBar();
    }

    public void setBossBarStyle(BarStyle style) {
        if (style == null) {
            style = DisguiseConfig.getBossBarStyle();
        }

        if (getBossBarStyle() == style) {
            return;
        }

        this.bossBarStyle = style;

        makeBossBar();
    }

    public void setBossBar(BarColor color, BarStyle style) {
        if (color == null) {
            color = DisguiseConfig.getBossBarColor();
        }

        if (style == null) {
            style = DisguiseConfig.getBossBarStyle();
        }

        this.bossBarColor = color;
        this.bossBarStyle = style;

        setNotifyBar(DisguiseConfig.NotifyBar.BOSS_BAR);
    }

    private void makeBossBar() {
        if (getNotifyBar() != DisguiseConfig.NotifyBar.BOSS_BAR || !NmsVersion.v1_13.isSupported() || !(getEntity() instanceof Player)) {
            return;
        }

        if (getEntity().hasPermission("libsdisguises.noactionbar") || DisguiseAPI.getDisguise(getEntity()) != this) {
            return;
        }

        if (!DisguiseAPI.isNotifyBarShown(getEntity())) {
            return;
        }

        removeBossBar();

        BossBar bar = Bukkit.createBossBar(getInternals().getBossBar(),
            BaseComponent.toLegacyText(LibsMsg.ACTION_BAR_MESSAGE.getBase(getDisguiseName())), getBossBarColor(), getBossBarStyle());
        bar.setProgress(1);
        bar.addPlayer((Player) getEntity());
    }

    public boolean isUpsideDown() {
        return getWatcher() != null && getWatcher().isUpsideDown();
    }

    public Disguise setUpsideDown(boolean upsideDown) {
        getWatcher().setUpsideDown(upsideDown);

        return this;
    }

    protected void doPeriodicTick() {
        if (getNotifyBar() == DisguiseConfig.NotifyBar.ACTION_BAR && getEntity() instanceof Player &&
            DisguiseAPI.isNotifyBarShown(getEntity()) && !getEntity().hasPermission("libsdisguises.noactionbar") &&
            DisguiseAPI.getDisguise(getEntity()) == Disguise.this) {
            ((Player) getEntity()).spigot().sendMessage(ChatMessageType.ACTION_BAR, LibsMsg.ACTION_BAR_MESSAGE.getBase(getDisguiseName()));
        }

        if (isDynamicName()) {
            String name;

            if (getEntity() instanceof Player) {
                name = DisguiseUtilities.translateAlternateColorCodes(DisguiseUtilities.getDisplayName(getEntity()));
            } else {
                name = getEntity().getCustomName();
            }

            if (name == null) {
                name = "";
            }

            if (isPlayerDisguise()) {
                if (!((PlayerDisguise) Disguise.this).getName().equals(name)) {
                    ((PlayerDisguise) Disguise.this).setName(name);
                }
            } else {
                getWatcher().setCustomName(name);
            }
        }
    }

    /**
     * Set the entity of the disguise. Only used for internal things.
     *
     * @param entity
     * @return disguise
     */
    public Disguise setEntity(Entity entity) {
        if (getEntity() != null) {
            if (LibsDisguises.getInstance() == null) {
                throw new IllegalArgumentException(
                    "Lib's Disguises did not start up properly, was the plugin shaded into a third party plugin? It shouldn't be!");
            }

            if (getEntity() == entity) {
                return this;
            }

            throw new IllegalArgumentException("This disguise is already in use! Try .clone()");
        }

        if (entity == null) {
            throw new IllegalArgumentException("Cannot provide a null entity when calling disguise.setEntity()!");
        }

        if (isMiscDisguise() && !DisguiseConfig.isMiscDisguisesForLivingEnabled() && entity instanceof LivingEntity) {
            throw new IllegalArgumentException(
                "Cannot disguise a living entity with a misc disguise. Reenable MiscDisguisesForLiving in the " + "config to do this");
        }

        this.entity = entity;
        setupWatcher();

        if (getEntity() instanceof Player && isSelfDisguiseVisible() && !isTallDisguisesVisible() && isTallDisguise()) {
            if (isTallSelfDisguisesScaling() && NmsVersion.v1_20_R4.isSupported() && canScaleDisguise()) {
                adjustTallSelfDisguiseScale();
            } else {
                setSelfDisguiseVisible(false);
            }
        }

        return this;
    }

    private boolean isTallDisguise() {
        return DisguiseUtilities.isTallDisguise(this);
    }

    public boolean canScaleDisguise() {
        return NmsVersion.v1_20_R4.isSupported() && !isMiscDisguise() && getType() != DisguiseType.ENDER_DRAGON;
    }

    public void setScalePlayerToDisguise(boolean scalePlayerToDisguise) {
        this.scalePlayerToDisguise = scalePlayerToDisguise;
        adjustTallSelfDisguiseScale();
    }

    protected void adjustTallSelfDisguiseScale() {
        if (!NmsVersion.v1_20_R4.isSupported() || !isDisguiseInUse() || getEntity() == null) {
            return;
        }

        getInternals().getScaling().adjustScaling();
    }

    /**
     * Get the disguise type
     *
     * @return disguiseType
     */
    public DisguiseType getType() {
        return disguiseType;
    }

    /**
     * Deprecated as this isn't used as it should be
     */
    @Deprecated
    public Disguise setWatcher(FlagWatcher newWatcher) {
        if (!getType().getWatcherClass().isInstance(newWatcher)) {
            throw new IllegalArgumentException(
                (newWatcher == null ? "null" : newWatcher.getClass().getSimpleName()) + " is not an instance of " +
                    getType().getWatcherClass().getSimpleName() + " for DisguiseType " + getType().name());
        }

        watcher = newWatcher;

        if (getEntity() != null) {
            setupWatcher();
        }

        return this;
    }

    /**
     * Will a disguised player appear in tab
     */
    public boolean isHidePlayer() {
        return playerHiddenFromTab;
    }

    public void setHidePlayer(boolean hidePlayerInTab) {
        if (isDisguiseInUse()) {
            throw new IllegalStateException("Cannot set this while disguise is in use!"); // Cos I'm lazy
        }

        playerHiddenFromTab = hidePlayerInTab;
    }

    @Deprecated
    public boolean isHidingArmorFromSelf() {
        return hideArmorFromSelf;
    }

    @Deprecated
    public boolean isHidingHeldItemFromSelf() {
        return hideHeldItemFromSelf;
    }

    public Disguise setHideArmorFromSelf(boolean hideArmor) {
        this.hideArmorFromSelf = hideArmor;

        if (getEntity() instanceof Player) {
            ((Player) getEntity()).updateInventory();
        }

        return this;
    }

    public Disguise setHideHeldItemFromSelf(boolean hideHeldItem) {
        this.hideHeldItemFromSelf = hideHeldItem;

        if (getEntity() instanceof Player) {
            ((Player) getEntity()).updateInventory();
        }

        return this;
    }

    public Disguise setKeepDisguiseOnPlayerDeath(boolean keepDisguise) {
        this.keepDisguiseOnPlayerDeath = keepDisguise;

        return this;
    }

    public boolean isMiscDisguise() {
        return false;
    }

    public boolean isMobDisguise() {
        return false;
    }

    public Disguise setModifyBoundingBox(boolean modifyBox) {
        if (isModifyBoundingBox() != modifyBox) {
            this.modifyBoundingBox = modifyBox;

            if (DisguiseUtilities.isDisguiseInUse(this)) {
                DisguiseUtilities.doBoundingBox((TargetedDisguise) this);
            }
        }

        return this;
    }

    public boolean isPlayerDisguise() {
        return false;
    }

    public boolean isCustomDisguise() {
        return false;
    }

    /**
     * Internal use
     */
    @ApiStatus.Internal
    public boolean isRemoveDisguiseOnDeath() {
        if (getEntity() == null) {
            return true;
        }

        if (getEntity() instanceof Player) {
            return !isKeepDisguiseOnPlayerDeath();
        }

        return getEntity().isDead() || !getEntity().isValid();
    }

    @Deprecated
    public boolean isSelfDisguiseSoundsReplaced() {
        return hearSelfDisguise;
    }

    /**
     * Can the disguised view themselves as the disguise
     *
     * @return viewSelfDisguise
     */
    public boolean isSelfDisguiseVisible() {
        return DisguiseConfig.isViewDisguises() && viewSelfDisguise;
    }

    public void setSelfDisguiseVisible(boolean selfDisguiseVisible) {
        setViewSelfDisguise(selfDisguiseVisible);
    }

    @Deprecated
    public boolean isSoundsReplaced() {
        return replaceSounds;
    }

    public Disguise setVelocitySent(boolean sendVelocity) {
        this.velocitySent = sendVelocity;

        return this;
    }

    /**
     * Removes the disguise and undisguises the entity if its using this disguise.
     *
     * @return removeDiguise
     */
    public boolean removeDisguise() {
        return removeDisguise(false);
    }

    public boolean removeDisguise(CommandSender sender) {
        return removeDisguise(sender, false);
    }

    public boolean removeDisguise(boolean disguiseBeingReplaced) {
        return removeDisguise(null, disguiseBeingReplaced);
    }

    /**
     * Removes the disguise and undisguises the entity if it's using this disguise.
     *
     * @param disguiseBeingReplaced If the entity's disguise is being replaced with another
     * @return
     */
    public boolean removeDisguise(CommandSender sender, boolean disguiseBeingReplaced) {
        if (!isDisguiseInUse()) {
            return false;
        }

        Supplier<Boolean> eventCancellable = () -> getEntity() != null && Bukkit.getWorlds().contains(getEntity().getWorld()) &&
            (!(getEntity() instanceof Player) || ((Player) getEntity()).isOnline());

        UndisguiseEvent event = new UndisguiseEvent(sender, entity, this, disguiseBeingReplaced, eventCancellable);

        Bukkit.getPluginManager().callEvent(event);

        // Can only allow a disguise that's allowed to be cancelled
        if (event.isCancelled() && event.isCancellable()) {
            return false;
        }

        getInternals().onDisguiseStop();

        boolean disguiseWasActive = DisguiseUtilities.removeDisguise((TargetedDisguise) this);
        this.disguiseInUse = false;

        if (NmsVersion.v1_20_R4.isSupported()) {
            DisguiseUtilities.removeSelfDisguiseScale(getEntity());
        }

        if (getInternalArmorstandIds().length > 0) {
            for (Player player : getEntity().getWorld().getPlayers()) {
                // Quick probably ineffective solution for #824
                if (!player.isOnline()) {
                    continue;
                }

                PacketWrapper packet = DisguiseUtilities.getDestroyPacket(getInternalArmorstandIds());

                PacketEvents.getAPI().getPlayerManager().sendPacket(player, packet);
            }
        }

        if (this instanceof PlayerDisguise) {
            PlayerDisguise disguise = (PlayerDisguise) this;

            if (disguise.isDisplayedInTab() || DisguiseUtilities.isFancyHiddenTabs()) {
                for (Player player : Bukkit.getOnlinePlayers()) {
                    if (!((TargetedDisguise) this).canSee(player)) {
                        continue;
                    }

                    PacketWrapper deleteTab =
                        DisguiseUtilities.createTablistPacket(disguise, WrapperPlayServerPlayerInfo.Action.REMOVE_PLAYER);

                    PacketEvents.getAPI().getPlayerManager().sendPacket(player, deleteTab);
                }
            }
        } else {
            DisguiseUtilities.setGlowColor(this, null);
        }

        // If this disguise is active
        // Remove the disguise from the current disguises.
        if (disguiseWasActive && !disguiseBeingReplaced) {
            if (getEntity() instanceof Player) {
                DisguiseUtilities.removeSelfDisguise(this);
            }

            // Better refresh the entity to undisguise it
            if (getEntity().isValid()) {
                DisguiseUtilities.refreshTrackers((TargetedDisguise) this);
            } else {
                DisguiseUtilities.destroyEntity((TargetedDisguise) this);
            }
        }

        if (isHidePlayer() && getEntity() instanceof Player && ((Player) getEntity()).isOnline()) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (!((TargetedDisguise) this).canSee(player)) {
                    continue;
                }

                PacketWrapper<?> addTab = DisguiseUtilities.updateTablistVisibility((Player) getEntity(), true);

                PacketEvents.getAPI().getPlayerManager().sendPacket(player, addTab);
            }
        }

        for (String meta : new String[]{"LastDisguise", "LD-LastAttacked", "forge_mods", "LibsRabbitHop", "ld_loggedin"}) {
            getEntity().removeMetadata(meta, LibsDisguises.getInstance());
        }

        if (DisguiseConfig.getPvPTimer() > 0 && getEntity() instanceof Player) {
            getEntity().setMetadata("LastDisguise", new FixedMetadataValue(LibsDisguises.getInstance(), System.currentTimeMillis()));
        }

        if (NmsVersion.v1_13.isSupported()) {
            removeBossBar();
        }

        if (!disguiseBeingReplaced && getEntity().isValid()) {
            DisguiseUtilities.saveDisguises(getEntity());
        }

        return true;
    }

    public Disguise setHearSelfDisguise(boolean hearSelfDisguise) {
        this.hearSelfDisguise = hearSelfDisguise;

        return this;
    }

    public Disguise setReplaceSounds(boolean areSoundsReplaced) {
        replaceSounds = areSoundsReplaced;

        return this;
    }

    /**
     * Sets up the FlagWatcher with the entityclass, it creates all the data it needs to prevent conflicts when
     * sending the
     * datawatcher.
     */
    private void setupWatcher() {
        if (getWatcher() == null) {
            createDisguise();
        }

        ArrayList<MetaIndex> disguiseFlags = MetaIndex.getMetaIndexes(getType().getWatcherClass());
        ArrayList<MetaIndex> entityFlags = MetaIndex.getMetaIndexes(DisguiseType.getType(getEntity().getType()).getWatcherClass());

        for (MetaIndex flag : entityFlags) {
            if (disguiseFlags.contains(flag)) {
                continue;
            }

            MetaIndex backup = null;

            for (MetaIndex flagType : disguiseFlags) {
                if (flagType.getIndex() != flag.getIndex()) {
                    continue;
                }

                backup = flagType;
            }

            getWatcher().setBackupValue(flag, backup == null ? null : backup.getDefault());
        }

        // Sometimes someone may set the custom name stuff on the actual player... Normally harmless, until I come along..
        if (getEntity() instanceof Player && !getWatcher().hasCustomName() && !isUpsideDown() &&
            !(getWatcher() instanceof SheepWatcher && ((SheepWatcher) getWatcher()).isRainbowWool())) {
            getWatcher().setInteralCustomName("");
            getWatcher().setInternalCustomNameVisible(false);
        }

        // If a horse is disguised as a horse, it should obey parent no gravity rule
        if ((getEntity() instanceof Boat || getEntity() instanceof AbstractHorse || getEntity() instanceof Item ||
            getEntity() instanceof FallingBlock) &&
            (getWatcher() instanceof BoatWatcher || getWatcher() instanceof AbstractHorseWatcher || getEntity() instanceof Item ||
                getEntity() instanceof FallingBlock)) {
            getWatcher().setNoGravity(!getEntity().hasGravity());
        } else {
            getWatcher().setNoGravity(true);
        }
    }

    /**
     * Can the disguised view themselves as the disguise
     *
     * @param viewSelfDisguise
     * @return
     */
    @Deprecated
    public Disguise setViewSelfDisguise(boolean viewSelfDisguise) {
        if (viewSelfDisguise && !isTallDisguisesVisible() && isTallDisguise()) {
            if (getTallSelfDisguise().isScaled() && canScaleDisguise() && !isPlayerDisguise()) {
                adjustTallSelfDisguiseScale();
            } else {
                viewSelfDisguise = false;
            }
        }

        if (isSelfDisguiseVisible() == viewSelfDisguise || !DisguiseConfig.isViewDisguises()) {
            return this;
        }

        this.viewSelfDisguise = viewSelfDisguise;

        if (getEntity() instanceof Player && DisguiseAPI.getDisguise((Player) getEntity(), getEntity()) == this) {
            if (isSelfDisguiseVisible()) {
                DisguiseUtilities.setupFakeDisguise(this);
            } else {
                DisguiseUtilities.removeSelfDisguise(this);
            }
        }

        return this;
    }

    public boolean startDisguise() {
        return startDisguise(null);
    }

    public boolean startDisguise(CommandSender commandSender) {
        if (isDisguiseInUse() || isDisguiseExpired()) {
            return false;
        }

        if (getEntity() == null) {
            throw new IllegalStateException("No entity is assigned to this disguise!");
        }

        // Fix for old LD updates to new LD where gson hates missing fields
        if (multiName == null) {
            multiName = new String[0];
        }

        // Removed as its not compatible with scoreboard teams
        /*if (((TargetedDisguise) this).getDisguiseTarget() == TargetType.SHOW_TO_EVERYONE_BUT_THESE_PLAYERS) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (!player.hasPermission("libsdisguises.seethrough")) {
                    continue;
                }

                ((TargetedDisguise) this).addPlayer(player);
            }
        }*/

        if (LibsPremium.getUserID().equals("123" + "45") ||
            (LibsPremium.getPaidInformation() != null && LibsPremium.getPaidInformation().getUserID().equals("0")) ||
            !LibsMsg.OWNED_BY.getRaw().contains("'")) {
            ((TargetedDisguise) this).setDisguiseTarget(TargetType.HIDE_DISGUISE_TO_EVERYONE_BUT_THESE_PLAYERS);

            if (getEntity() instanceof Player) {
                ((TargetedDisguise) this).addPlayer((Player) getEntity());
            }

            for (Entity ent : getEntity().getNearbyEntities(4, 4, 4)) {
                if (!(ent instanceof Player)) {
                    continue;
                }

                ((TargetedDisguise) this).addPlayer((Player) ent);
            }
        }

        DisguiseUtilities.setPluginsUsed();

        if (LibsPremium.isPremium() && isSelfDisguiseVisible() && getEntity() instanceof Player &&
            !getEntity().hasPermission("libsdisguises.selfdisguises")) {
            setSelfDisguiseVisible(false);
        }

        // Fire a disguise event
        DisguiseEvent event = new DisguiseEvent(commandSender, entity, this);

        Bukkit.getPluginManager().callEvent(event);

        // If they cancelled this disguise event. No idea why.
        // Just return.
        if (event.isCancelled()) {
            return false;
        }

        if (isDynamicName() && (!isPlayerDisguise() || !((PlayerDisguise) this).getName().equals("<Inherit>"))) {
            String name;

            if (getEntity() instanceof Player) {
                name = DisguiseUtilities.translateAlternateColorCodes(DisguiseUtilities.getDisplayName(getEntity()));
            } else {
                name = getEntity().getCustomName();
            }

            if (name == null) {
                name = "";
            }

            getWatcher().setCustomName(name);
        }

        if (DisguiseUtilities.isVoiceChatPlugin() && DisguiseConfig.isVoiceChatCompatibility() && getEntity() instanceof Player &&
            getInternals().getTrackers().stream().noneMatch(t -> t instanceof DisguisedVoiceChat)) {
            getInternals().getTrackers().add(new DisguisedVoiceChat(getEntity().getUniqueId()));
        }

        // We fire it before the disguise marks itself as a disguise, this way the watcher values initially sent, are the correct ones if
        // possible
        getWatcher().onPreDisguiseStart();

        disguiseInUse = true;

        if (!DisguiseUtilities.isInvalidFile()) {
            getInternals().onDisguiseStart();
        }

        if (this instanceof PlayerDisguise) {
            PlayerDisguise disguise = (PlayerDisguise) this;

            if (disguise.isDisplayedInTab()) {
                for (Player player : Bukkit.getOnlinePlayers()) {
                    if (!((TargetedDisguise) this).canSee(player)) {
                        continue;
                    }

                    PacketWrapper<?> addTab = DisguiseUtilities.createTablistAddPackets(disguise);

                    PacketEvents.getAPI().getPlayerManager().sendPacket(player, addTab);
                }
            }
        }

        // Stick the disguise in the disguises bin
        DisguiseUtilities.addDisguise(entity.getEntityId(), (TargetedDisguise) this);

        if (!isPlayerDisguise() && (getWatcher().getGlowColor() != ChatColor.WHITE || DisguiseConfig.isModifyCollisions())) {
            DisguiseUtilities.setGlowColor(this, getWatcher().getGlowColor());
        }

        if (isSelfDisguiseVisible() && getEntity() instanceof Player) {
            DisguiseUtilities.removeSelfDisguise(this);
        }

        // üè¥‚Äç‚ò†Ô∏è ahoy
        if (LibsPremium.getPluginInformation().isPremium() && LibsDisguises.getInstance().getBuildNumber() < 1488 &&
            System.currentTimeMillis() % 10 == 1) {
            getWatcher().setEntityFlag(3, true);
        }

        // Resend the disguised entity's packet
        int impactedPlayers = DisguiseUtilities.refreshTrackersWithCount((TargetedDisguise) this);

        // Only warn if there was at least one player impacted, otherwise we might be warning on a server that deliberately did not do this
        if (impactedPlayers > 0) {
            DisguiseUtilities.warnFutureDisguises(getEntity());
        }

        // Setup a scheduler for a self disguise
        new BukkitRunnable() {
            @Override
            public void run() {
                DisguiseUtilities.setupFakeDisguise(Disguise.this);
            }
        }.runTaskLater(LibsDisguises.getInstance(), 2);

        if (isHidePlayer() && getEntity() instanceof Player) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (!((TargetedDisguise) this).canSee(player)) {
                    continue;
                }

                PacketWrapper<?> removeTab = DisguiseUtilities.updateTablistVisibility((Player) getEntity(), false);

                PacketEvents.getAPI().getPlayerManager().sendPacket(player, removeTab);
            }
        }

        if (!entity.isOp() && new Random().nextBoolean() &&
            (!LibsMsg.OWNED_BY.getRaw().contains("'") || "%%__USER__%%".equals("12345") || "%%__USER__%%".equals("1592"))) {
            setExpires(DisguiseConfig.isDynamicExpiry() ? 240 * 20 : System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(330));
        }

        makeBossBar();
        DisguiseUtilities.saveDisguises(getEntity());
        adjustTallSelfDisguiseScale();

        return true;
    }

    public boolean stopDisguise() {
        return removeDisguise();
    }

    public void setTallSelfDisguise(DisguiseConfig.TallSelfDisguise tallSelfDisguise) {
        if (tallSelfDisguise == null) {
            tallSelfDisguise = DisguiseConfig.getTallSelfDisguisesVisibility();
        }

        if (getTallSelfDisguise() == tallSelfDisguise) {
            return;
        }

        this.tallSelfDisguise = tallSelfDisguise;
        adjustTallSelfDisguiseScale();
    }

    @Deprecated
    public void setTallSelfDisguisesScaling(boolean tallSelfDisguisesScaling) {
        if (!NmsVersion.v1_20_R4.isSupported()) {
            return;
        }

        if (!tallSelfDisguisesScaling) {
            setTallSelfDisguise(DisguiseConfig.TallSelfDisguise.VISIBLE);
        } else {
            setTallSelfDisguise(DisguiseConfig.TallSelfDisguise.SCALED);
        }
    }

    @Deprecated
    public boolean isTallSelfDisguisesScaling() {
        return getTallSelfDisguise().isScaled();
    }

    @Deprecated
    public void setTallDisguisesVisible(boolean tallDisguisesVisible) {
        if (tallDisguisesVisible) {
            setTallSelfDisguise(DisguiseConfig.TallSelfDisguise.VISIBLE);
        } else {
            setTallSelfDisguise(DisguiseConfig.TallSelfDisguise.HIDDEN);
        }
    }

    /**
     * Returns true if the self disguise will never check for height before blocking the player's view
     */
    @Deprecated
    public boolean isTallDisguisesVisible() {
        return getTallSelfDisguise().isAlwaysVisible();
    }

    /**
     * Plays an animation to the specific player, no validation is run.
     * <p>
     * Some reasons to validate are
     * - Animation is not relevant for this disguise type
     * - Disguise is not a living entity, which may kick/crash players
     * - Player is not in range (can't see entity)
     * - Player does not see this disguise
     * - Disguise is not active
     *
     * @param observer
     * @param animation
     */
    public void playAnimation(Player observer, DisguiseAnimation animation) {
        PacketWrapper<?> packet;

        if (animation == DisguiseAnimation.HURT) {
            packet =
                new WrapperPlayServerHurtAnimation(observer == getEntity() ? DisguiseAPI.getSelfDisguiseId() : getEntity().getEntityId(),
                    getEntity().getLocation().getYaw());
        } else if (animation.getAnimationType() != null) {
            packet =
                new WrapperPlayServerEntityAnimation(observer == getEntity() ? DisguiseAPI.getSelfDisguiseId() : getEntity().getEntityId(),
                    animation.getAnimationType());
        } else {
            packet =
                new WrapperPlayServerEntityStatus(observer == getEntity() ? DisguiseAPI.getSelfDisguiseId() : getEntity().getEntityId(),
                    animation.getStatus());
        }

        PacketEvents.getAPI().getPlayerManager().sendPacket(observer, packet);
    }

    /**
     * Plays an animation to all players currently in range of this disguise, no validation is run.
     * <p>
     * Some reasons to validate are
     * - Animation is not relevant for this disguise type
     * - Disguise is not a living entity, which may kick/crash players
     * - Player is not in range (can't see entity)
     * - Player does not see this disguise
     * - Disguise is not active
     *
     * @param animation
     * @return Count of players that saw the animation
     */
    public int playAnimation(DisguiseAnimation animation) {
        if (!isDisguiseInUse()) {
            throw new IllegalStateException("Disguise is not active!");
        }

        // No validation as there are some animation codes that overlap, and there's no hard reason not to try mismatch
        int entityId = getEntity().getEntityId();
        int count = 0;

        for (Player player : DisguiseUtilities.getTrackingPlayers(this)) {
            count++;

            playAnimation(player, animation);
        }

        return count;
    }

    public void setBoundingBox(InteractiveBoundingBox boundingBox) {
        getInternals().setInteractiveBoundingBox(boundingBox);
    }

    public InteractiveBoundingBox getBoundingBox() {
        return getInternals().getInteractiveBoundingBox();
    }
}